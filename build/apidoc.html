<div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a

        href="https://www.npmjs.com/package/zombie"

    >zombie (v5.0.5)</a>
</h1>
<h4>Insanely fast, full-stack, headless browser testing using Node.js</h4>
<div class="apidocSectionDiv"><a
    href="#apidoc.tableOfContents"
    id="apidoc.tableOfContents"
><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.zombie">module zombie</a><ol>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">zombie.</span>runScripts</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">zombie.</span>silent</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">zombie.</span>strictSSL</span>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.zombie.zombie">
            function <span class="apidocSignatureSpan"></span>zombie
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.zombie.Assert">
            function <span class="apidocSignatureSpan">zombie.</span>Assert
            <span class="apidocSignatureSpan">(browser)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.zombie.Headers">
            function <span class="apidocSignatureSpan">zombie.</span>Headers
            <span class="apidocSignatureSpan">(init)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.zombie.Pipeline">
            function <span class="apidocSignatureSpan">zombie.</span>Pipeline
            <span class="apidocSignatureSpan">(browser)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.zombie.Request">
            function <span class="apidocSignatureSpan">zombie.</span>Request
            <span class="apidocSignatureSpan">(input, init)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.zombie.Response">
            function <span class="apidocSignatureSpan">zombie.</span>Response
            <span class="apidocSignatureSpan">(bodyInit, responseInit)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.zombie._debug">
            function <span class="apidocSignatureSpan">zombie.</span>_debug
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">zombie.</span>_debugEnabled</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">zombie.</span>_extensions</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">zombie.</span>proxy</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">zombie.</span>site</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">zombie.</span>VERSION</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">zombie.</span>features</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">zombie.</span>language</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">zombie.</span>localAddress</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">zombie.</span>userAgent</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">zombie.</span>waitDuration</span>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.zombie" id="apidoc.module.zombie">module zombie</a></h1>








    <h2>
        <a href="#apidoc.element.zombie.zombie" id="apidoc.element.zombie.zombie">
        function <span class="apidocSignatureSpan"></span>zombie
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Browser() {
  var _this = this;

  var options = arguments.length &#x3c;= 0 || arguments[0] === undefined ? {} : arguments[0];

  _classCallCheck(this, Browser);

  _get(Object.getPrototypeOf(Browser.prototype), &#x27;constructor&#x27;, this).call(this);
  // Used for assertions
  this.assert = new Assert(this);
  this.cookies = new Cookies();
  // Shared by all windows.
  this.console = new Console(this);
  // Start with no this referrer.
  this.referrer = null;
  // Open tabs.
  this.tabs = new Tabs(this);
  // New pipeline for this browser.
  this.pipeline = new Pipeline(this);

  // The browser event loop.
  this._eventLoop = new EventLoop(this);

  // Returns all errors reported while loading this window.
  this.errors = [];

  this._storages = new Storages();

  // The window that is currently in scope, some JS functions need this, e.g.
  // when closing a window, you need to determine whether caller (window in
  // scope) is same as window.opener
  this._windowInScope = null;

  this._debug = Browser._debug;

  // Message written to window.console.  Level is log, info, error, etc.
  //
  // All output goes to stdout, except when browser.silent = true and output
  // only shown when debugging (DEBUG=zombie).
  this.on(&#x27;console&#x27;, function (level, message) {
    if (_this.silent) _this._debug(&#x27;&#x3e;&#x3e; &#x27; + message);else console.log(message);
  }).on(&#x27;log&#x27;, function () {
    // Message written to browser.log.
    _this._debug(format.apply(undefined, arguments));
  });

  // Logging resources
  this.on(&#x27;request&#x27;, function (request) {
    return request;
  }).on(&#x27;response&#x27;, function (request, response) {
    _this._debug(&#x27;%s %s =&#x3e; %s&#x27;, request.method, response.url, response.status);
  }).on(&#x27;redirect&#x27;, function (request, response) {
    _this._debug(&#x27;%s %s =&#x3e; %s %s&#x27;, request.method, request.url, response.status, response.headers.get(&#x27;Location&#x27;));
  }).on(&#x27;loaded&#x27;, function (document) {
    _this._debug(&#x27;Loaded document %s&#x27;, document.location.href);
  }).on(&#x27;xhr&#x27;, function (eventName, url) {
    _this._debug(&#x27;XHR %s %s&#x27;, eventName, url);
  });

  // Logging windows/tabs/navigation
  this.on(&#x27;opened&#x27;, function (window) {
    _this._debug(&#x27;Opened window %s %s&#x27;, window.location.href, window.name || &#x27;&#x27;);
  }).on(&#x27;closed&#x27;, function (window) {
    _this._debug(&#x27;Closed window %s %s&#x27;, window.location.href, window.name || &#x27;&#x27;);
  });

  // Switching tabs/windows fires blur/focus event on active window/element
  this.on(&#x27;active&#x27;, function (window) {
    // Window becomes inactive
    var winFocus = window.document.createEvent(&#x27;HTMLEvents&#x27;);
    winFocus.initEvent(&#x27;focus&#x27;, false, false);
    window.dispatchEvent(winFocus);

    if (window.document.activeElement) {
      var elemFocus = window.document.createEvent(&#x27;HTMLEvents&#x27;);
      elemFocus.initEvent(&#x27;focus&#x27;, false, false);
      window.document.activeElement.dispatchEvent(elemFocus);
    }
  }).on(&#x27;inactive&#x27;, function (window) {
    // Window becomes inactive
    if (window.document.activeElement) {
      var elemBlur = window.document.createEvent(&#x27;HTMLEvents&#x27;);
      elemBlur.initEvent(&#x27;blur&#x27;, false, false);
      window.document.activeElement.dispatchEvent(elemBlur);
    }
    var winBlur = window.document.createEvent(&#x27;HTMLEvents&#x27;);
    winBlur.initEvent(&#x27;blur&#x27;, false, false);
    window.dispatchEvent(winBlur);
  });

  // Logging navigation
  this.on(&#x27;link&#x27;, function (url) {
    _this._debug(&#x27;Follow link to %s&#x27;, url);
  }).on(&#x27;submit&#x27;, function (url) {
    _this._debug(&#x27;Submit form to %s&#x27;, url);
  });

  // Logging event loop
  this._eventLoop.on(&#x27;setTimeout&#x27;, function (fn, delay) {
    _this._debug(&#x27;Fired setTimeout after %dms delay&#x27;, delay);
    _this.emit(&#x27;setTimeout&#x27;, fn, delay);
  }).on(&#x27;setInterval&#x27;, function (fn, interval) {
    _this._debug(&#x27;Fired setInterval every %dms&#x27;, interval);
    _this.emit(&#x27;setInterval&#x27;, fn, interval);
  }).on(&#x27;serverEvent&#x27;, function () {
    _this._debug(&#x27;Server initiated event&#x27;);
    _this.emit(&#x27;serverEvent&#x27;);
  }).on(&#x27;idle&#x27;, function (timedOut) {
    if (timedOut) _this._debug(&#x27;Event loop timed out&#x27;);else _this._debug(&#x27;Event loop is empty&#x27;);
    _this. ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.zombie.Assert" id="apidoc.element.zombie.Assert">
        function <span class="apidocSignatureSpan">zombie.</span>Assert
        <span class="apidocSignatureSpan">(browser)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Assert(browser) {
  _classCallCheck(this, Assert);

  this.browser = browser;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.zombie.Headers" id="apidoc.element.zombie.Headers">
        function <span class="apidocSignatureSpan">zombie.</span>Headers
        <span class="apidocSignatureSpan">(init)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Headers(init) {
  var _this = this;

  _classCallCheck(this, Headers);

  this._headers = [];
  if (init instanceof Headers || init instanceof Array) {
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = _getIterator(init), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion
 = true) {
        var _step$value = _slicedToArray(_step.value, 2);

        var _name = _step$value[0];
        var value = _step$value[1];

        this.append(_name, value);
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion &#x26;&#x26; _iterator[&#x27;return&#x27;]) {
          _iterator[&#x27;return&#x27;]();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }
  } else if (typeof init === &#x22;object&#x22;) _.each(init, function (value, name) {
    _this.append(name, value);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var browser = args.browser;
var method = args.method;

var params = args.params || new _Map();
var site = /^(https?:|file:)/i.test(browser.site) ? browser.site : &#x27;http://&#x27; + (browser.site || &#x27;locahost&#x27;);
var url = Utils.resolveHref(site, URL.format(args.url));

var headers = new Fetch.<span class="apidocCodeKeywordSpan">Headers</span>(args.headers);

// HTTP header Referer, but Document property referrer
var referrer = args.referrer || browser.referrer || browser.referer || args.history.url;
if (referrer &#x26;&#x26; !headers.has(&#x27;Referer&#x27;)) headers.set(&#x27;Referer&#x27;, referrer);
if (!headers.has(&#x27;Accept&#x27;)) headers.set(&#x27;Accept&#x27;, &#x27;text/html,*/*&#x27;);

if (/^GET|HEAD|DELETE$/i.test(method)) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.zombie.Pipeline" id="apidoc.element.zombie.Pipeline">
        function <span class="apidocSignatureSpan">zombie.</span>Pipeline
        <span class="apidocSignatureSpan">(browser)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Pipeline(browser) {
  _classCallCheck(this, Pipeline);

  _get(Object.getPrototypeOf(Pipeline.prototype), &#x27;constructor&#x27;, this).call(this);
  this._browser = browser;
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = _getIterator(Pipeline._default), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done);
_iteratorNormalCompletion = true) {
      var handler = _step.value;

      this.push(handler);
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion &#x26;&#x26; _iterator[&#x27;return&#x27;]) {
        _iterator[&#x27;return&#x27;]();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.zombie.Request" id="apidoc.element.zombie.Request">
        function <span class="apidocSignatureSpan">zombie.</span>Request
        <span class="apidocSignatureSpan">(input, init)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Request(input, init) {
  _classCallCheck(this, Request);

  var method = ((init ? init.method : input.method) || &#x27;GET&#x27;).toUpperCase();
  var bodyInit = null;

  if (input instanceof Request &#x26;&#x26; input._stream) {
    if (input._bodyUsed) throw new TypeError(&#x27;Request body already used&#x27;);
    bodyInit = input;
    input._bodyUsed = true;
  }

  if (init &#x26;&#x26; init.body) {
    if (method === &#x27;GET&#x27; || method === &#x27;HEAD&#x27;) throw new TypeError(&#x27;Cannot include body with GET/HEAD request&#x27;);
    bodyInit = init.body;
  }
  _get(Object.getPrototypeOf(Request.prototype), &#x27;constructor&#x27;, this).call(this, bodyInit);

  if (typeof input === &#x27;string&#x27; || input instanceof String) this.url = URL.format(input);else if (input instanceof Request) this
.url = input.url;
  if (!this.url) throw new TypeError(&#x27;Input must be string or another Request&#x27;);

  this.method = method;
  this.headers = new Headers(init ? init.headers : input.headers);
  if (this._contentType &#x26;&#x26; !this.headers.has(&#x27;Content-Type&#x27;)) this.headers.set(&#x27;Content-Type&#x27;, this._contentType);

  // Default redirect is follow, also treat manual as follow
  this.redirect = init &#x26;&#x26; init.redirect;
  if (this.redirect !== &#x27;error&#x27;) this.redirect = &#x27;follow&#x27;;
  this._redirectCount = 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    } finally {
      if (_didIteratorError3) {
        throw _iteratorError3;
      }
    }
  }

  return new Fetch.<span class="apidocCodeKeywordSpan">Request</span>(URL.format(uri), { method: method, headers: headers });
}

var mimeType = (args.encoding || &#x27;&#x27;).split(&#x27;;&#x27;)[0];
// Default mime type, but can also be specified in form encoding
if (mimeType === &#x27;&#x27; || mimeType === &#x27;application/x-www-form-urlencoded&#x27;) {
  var urlEncoded = [].concat(_toConsumableArray(params)).map(function (_ref) {
    var _ref2 = _slicedToArray(_ref, 2);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.zombie.Response" id="apidoc.element.zombie.Response">
        function <span class="apidocSignatureSpan">zombie.</span>Response
        <span class="apidocSignatureSpan">(bodyInit, responseInit)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Response(bodyInit, responseInit) {
  _classCallCheck(this, Response);

  _get(Object.getPrototypeOf(Response.prototype), &#x27;constructor&#x27;, this).call(this, bodyInit);
  if (responseInit) {
    if (responseInit.status &#x3c; 200 || responseInit.status &#x3e; 599) throw new RangeError(&#x27;Status code &#x27; + responseInit.status + &#x27; not
 in range&#x27;);
    var statusText = responseInit.statusText || HTTP.STATUS_CODES[responseInit.status] || &#x27;Unknown&#x27;;
    if (!/^[^\n\r]+$/.test(statusText)) throw new TypeError(&#x27;Status text &#x27; + responseInit.statusText + &#x27; not valid format&#x27;);

    this._url = URL.format(responseInit.url || &#x27;&#x27;);
    this.type = &#x27;default&#x27;;
    this.status = responseInit.status;
    this.statusText = statusText;
    this.headers = new Headers(responseInit.headers);
  } else {
    this.type = &#x27;error&#x27;;
    this.status = 0;
    this.statusText = &#x27;&#x27;;
    this.headers = new Headers();
  }
  if (this._contentType &#x26;&#x26; !this.headers.has(&#x27;Content-Type&#x27;)) this.headers.set(&#x27;Content-Type&#x27;, this._contentType);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      var pathname = _URL$parse2.pathname;

      if (protocol === &#x27;file:&#x27;) {

// If the request is for a file:// descriptor, just open directly from the
// file system rather than getting node&#x27;s http (which handles file://
// poorly) involved.
if (request.method !== &#x27;GET&#x27;) return new Fetch.<span class="apidocCodeKeywordSpan">Response</span>(&#x27;&#x27;, { url
: url, status: 405 });

var filename = Path.normalize(decodeURI(pathname));
var exists = File.existsSync(filename);
if (exists) {
  var stream = File.createReadStream(filename);
  return new Fetch.Response(stream, { url: url, status: 200 });
} else return new Fetch.Response(&#x27;&#x27;, { url: url, status: 404 });
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.zombie._debug" id="apidoc.element.zombie._debug">
        function <span class="apidocSignatureSpan">zombie.</span>_debug
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function debug() {
  // disabled?
  if (!debug.enabled) return;

  var self = debug;

  // set `diff` timestamp
  var curr = +new Date();
  var ms = curr - (prevTime || curr);
  self.diff = ms;
  self.prev = prevTime;
  self.curr = curr;
  prevTime = curr;

  // turn the `arguments` into a proper Array
  var args = new Array(arguments.length);
  for (var i = 0; i &#x3c; args.length; i++) {
    args[i] = arguments[i];
  }

  args[0] = exports.coerce(args[0]);

  if (&#x27;string&#x27; !== typeof args[0]) {
    // anything else let&#x27;s inspect with %O
    args.unshift(&#x27;%O&#x27;);
  }

  // apply any `formatters` transformations
  var index = 0;
  args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match, format) {
    // if we encounter an escaped % then don&#x27;t increase the array index
    if (match === &#x27;%%&#x27;) return match;
    index++;
    var formatter = exports.formatters[format];
    if (&#x27;function&#x27; === typeof formatter) {
      var val = args[index];
      match = formatter.call(self, val);

      // now we need to remove `args[index]` since it&#x27;s inlined in the `format`
      args.splice(index, 1);
      index--;
    }
    return match;
  });

  // apply env-specific formatting (colors, etc.)
  exports.formatArgs.call(self, args);

  var logFn = debug.log || exports.log || console.log.bind(console);
  logFn.apply(self, args);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
this._debug = Browser._debug;

// Message written to window.console.  Level is log, info, error, etc.
//
// All output goes to stdout, except when browser.silent = true and output
// only shown when debugging (DEBUG=zombie).
this.on(&#x27;console&#x27;, function (level, message) {
  if (_this.silent) _this.<span class="apidocCodeKeywordSpan">_debug</span>(&#x27;&#x3e;&#x3e; &#x27; + message);else console.log
(message);
}).on(&#x27;log&#x27;, function () {
  // Message written to browser.log.
  _this._debug(format.apply(undefined, arguments));
});

// Logging resources
this.on(&#x27;request&#x27;, function (request) {
...</pre></li>
    </ul>






















</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
