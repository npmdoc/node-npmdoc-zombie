<html><head></head><body><div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a href="https://www.npmjs.com/package/zombie">zombie (v5.0.5)</a>
</h1>
<h4>Insanely fast, full-stack, headless browser testing using Node.js</h4>
<div class="apidocSectionDiv"><a href="#apidoc.tableOfContents" id="apidoc.tableOfContents"><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.zombie">module zombie</a><ol>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">zombie.</span>runScripts</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">zombie.</span>silent</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">zombie.</span>strictSSL</span>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.zombie.zombie">
            function <span class="apidocSignatureSpan"></span>zombie
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.zombie.Assert">
            function <span class="apidocSignatureSpan">zombie.</span>Assert
            <span class="apidocSignatureSpan">(browser)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.zombie.Headers">
            function <span class="apidocSignatureSpan">zombie.</span>Headers
            <span class="apidocSignatureSpan">(init)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.zombie.Pipeline">
            function <span class="apidocSignatureSpan">zombie.</span>Pipeline
            <span class="apidocSignatureSpan">(browser)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.zombie.Request">
            function <span class="apidocSignatureSpan">zombie.</span>Request
            <span class="apidocSignatureSpan">(input, init)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.zombie.Response">
            function <span class="apidocSignatureSpan">zombie.</span>Response
            <span class="apidocSignatureSpan">(bodyInit, responseInit)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.zombie._debug">
            function <span class="apidocSignatureSpan">zombie.</span>_debug
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">zombie.</span>_debugEnabled</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">zombie.</span>_extensions</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">zombie.</span>proxy</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">zombie.</span>site</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">zombie.</span>VERSION</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">zombie.</span>features</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">zombie.</span>language</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">zombie.</span>localAddress</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">zombie.</span>userAgent</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">zombie.</span>waitDuration</span>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.zombie" id="apidoc.module.zombie">module zombie</a></h1>








    <h2>
        <a href="#apidoc.element.zombie.zombie" id="apidoc.element.zombie.zombie">
        function <span class="apidocSignatureSpan"></span>zombie
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Browser() {
  var _this = this;

  var options = arguments.length &lt;= 0 || arguments[0] === undefined ? {} : arguments[0];

  _classCallCheck(this, Browser);

  _get(Object.getPrototypeOf(Browser.prototype), 'constructor', this).call(this);
  // Used for assertions
  this.assert = new Assert(this);
  this.cookies = new Cookies();
  // Shared by all windows.
  this.console = new Console(this);
  // Start with no this referrer.
  this.referrer = null;
  // Open tabs.
  this.tabs = new Tabs(this);
  // New pipeline for this browser.
  this.pipeline = new Pipeline(this);

  // The browser event loop.
  this._eventLoop = new EventLoop(this);

  // Returns all errors reported while loading this window.
  this.errors = [];

  this._storages = new Storages();

  // The window that is currently in scope, some JS functions need this, e.g.
  // when closing a window, you need to determine whether caller (window in
  // scope) is same as window.opener
  this._windowInScope = null;

  this._debug = Browser._debug;

  // Message written to window.console.  Level is log, info, error, etc.
  //
  // All output goes to stdout, except when browser.silent = true and output
  // only shown when debugging (DEBUG=zombie).
  this.on('console', function (level, message) {
    if (_this.silent) _this._debug('&gt;&gt; ' + message);else console.log(message);
  }).on('log', function () {
    // Message written to browser.log.
    _this._debug(format.apply(undefined, arguments));
  });

  // Logging resources
  this.on('request', function (request) {
    return request;
  }).on('response', function (request, response) {
    _this._debug('%s %s =&gt; %s', request.method, response.url, response.status);
  }).on('redirect', function (request, response) {
    _this._debug('%s %s =&gt; %s %s', request.method, request.url, response.status, response.headers.get('Location'));
  }).on('loaded', function (document) {
    _this._debug('Loaded document %s', document.location.href);
  }).on('xhr', function (eventName, url) {
    _this._debug('XHR %s %s', eventName, url);
  });

  // Logging windows/tabs/navigation
  this.on('opened', function (window) {
    _this._debug('Opened window %s %s', window.location.href, window.name || '');
  }).on('closed', function (window) {
    _this._debug('Closed window %s %s', window.location.href, window.name || '');
  });

  // Switching tabs/windows fires blur/focus event on active window/element
  this.on('active', function (window) {
    // Window becomes inactive
    var winFocus = window.document.createEvent('HTMLEvents');
    winFocus.initEvent('focus', false, false);
    window.dispatchEvent(winFocus);

    if (window.document.activeElement) {
      var elemFocus = window.document.createEvent('HTMLEvents');
      elemFocus.initEvent('focus', false, false);
      window.document.activeElement.dispatchEvent(elemFocus);
    }
  }).on('inactive', function (window) {
    // Window becomes inactive
    if (window.document.activeElement) {
      var elemBlur = window.document.createEvent('HTMLEvents');
      elemBlur.initEvent('blur', false, false);
      window.document.activeElement.dispatchEvent(elemBlur);
    }
    var winBlur = window.document.createEvent('HTMLEvents');
    winBlur.initEvent('blur', false, false);
    window.dispatchEvent(winBlur);
  });

  // Logging navigation
  this.on('link', function (url) {
    _this._debug('Follow link to %s', url);
  }).on('submit', function (url) {
    _this._debug('Submit form to %s', url);
  });

  // Logging event loop
  this._eventLoop.on('setTimeout', function (fn, delay) {
    _this._debug('Fired setTimeout after %dms delay', delay);
    _this.emit('setTimeout', fn, delay);
  }).on('setInterval', function (fn, interval) {
    _this._debug('Fired setInterval every %dms', interval);
    _this.emit('setInterval', fn, interval);
  }).on('serverEvent', function () {
    _this._debug('Server initiated event');
    _this.emit('serverEvent');
  }).on('idle', function (timedOut) {
    if (timedOut) _this._debug('Event loop timed out');else _this._debug('Event loop is empty');
    _this. ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.zombie.Assert" id="apidoc.element.zombie.Assert">
        function <span class="apidocSignatureSpan">zombie.</span>Assert
        <span class="apidocSignatureSpan">(browser)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Assert(browser) {
  _classCallCheck(this, Assert);

  this.browser = browser;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.zombie.Headers" id="apidoc.element.zombie.Headers">
        function <span class="apidocSignatureSpan">zombie.</span>Headers
        <span class="apidocSignatureSpan">(init)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Headers(init) {
  var _this = this;

  _classCallCheck(this, Headers);

  this._headers = [];
  if (init instanceof Headers || init instanceof Array) {
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = _getIterator(init), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion
 = true) {
        var _step$value = _slicedToArray(_step.value, 2);

        var _name = _step$value[0];
        var value = _step$value[1];

        this.append(_name, value);
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion &amp;&amp; _iterator['return']) {
          _iterator['return']();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }
  } else if (typeof init === "object") _.each(init, function (value, name) {
    _this.append(name, value);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var browser = args.browser;
var method = args.method;

var params = args.params || new _Map();
var site = /^(https?:|file:)/i.test(browser.site) ? browser.site : 'http://' + (browser.site || 'locahost');
var url = Utils.resolveHref(site, URL.format(args.url));

var headers = new Fetch.<span class="apidocCodeKeywordSpan">Headers</span>(args.headers);

// HTTP header Referer, but Document property referrer
var referrer = args.referrer || browser.referrer || browser.referer || args.history.url;
if (referrer &amp;&amp; !headers.has('Referer')) headers.set('Referer', referrer);
if (!headers.has('Accept')) headers.set('Accept', 'text/html,*/*');

if (/^GET|HEAD|DELETE$/i.test(method)) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.zombie.Pipeline" id="apidoc.element.zombie.Pipeline">
        function <span class="apidocSignatureSpan">zombie.</span>Pipeline
        <span class="apidocSignatureSpan">(browser)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Pipeline(browser) {
  _classCallCheck(this, Pipeline);

  _get(Object.getPrototypeOf(Pipeline.prototype), 'constructor', this).call(this);
  this._browser = browser;
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = _getIterator(Pipeline._default), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done);
_iteratorNormalCompletion = true) {
      var handler = _step.value;

      this.push(handler);
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion &amp;&amp; _iterator['return']) {
        _iterator['return']();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.zombie.Request" id="apidoc.element.zombie.Request">
        function <span class="apidocSignatureSpan">zombie.</span>Request
        <span class="apidocSignatureSpan">(input, init)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Request(input, init) {
  _classCallCheck(this, Request);

  var method = ((init ? init.method : input.method) || 'GET').toUpperCase();
  var bodyInit = null;

  if (input instanceof Request &amp;&amp; input._stream) {
    if (input._bodyUsed) throw new TypeError('Request body already used');
    bodyInit = input;
    input._bodyUsed = true;
  }

  if (init &amp;&amp; init.body) {
    if (method === 'GET' || method === 'HEAD') throw new TypeError('Cannot include body with GET/HEAD request');
    bodyInit = init.body;
  }
  _get(Object.getPrototypeOf(Request.prototype), 'constructor', this).call(this, bodyInit);

  if (typeof input === 'string' || input instanceof String) this.url = URL.format(input);else if (input instanceof Request) this
.url = input.url;
  if (!this.url) throw new TypeError('Input must be string or another Request');

  this.method = method;
  this.headers = new Headers(init ? init.headers : input.headers);
  if (this._contentType &amp;&amp; !this.headers.has('Content-Type')) this.headers.set('Content-Type', this._contentType);

  // Default redirect is follow, also treat manual as follow
  this.redirect = init &amp;&amp; init.redirect;
  if (this.redirect !== 'error') this.redirect = 'follow';
  this._redirectCount = 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    } finally {
      if (_didIteratorError3) {
        throw _iteratorError3;
      }
    }
  }

  return new Fetch.<span class="apidocCodeKeywordSpan">Request</span>(URL.format(uri), { method: method, headers: headers });
}

var mimeType = (args.encoding || '').split(';')[0];
// Default mime type, but can also be specified in form encoding
if (mimeType === '' || mimeType === 'application/x-www-form-urlencoded') {
  var urlEncoded = [].concat(_toConsumableArray(params)).map(function (_ref) {
    var _ref2 = _slicedToArray(_ref, 2);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.zombie.Response" id="apidoc.element.zombie.Response">
        function <span class="apidocSignatureSpan">zombie.</span>Response
        <span class="apidocSignatureSpan">(bodyInit, responseInit)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Response(bodyInit, responseInit) {
  _classCallCheck(this, Response);

  _get(Object.getPrototypeOf(Response.prototype), 'constructor', this).call(this, bodyInit);
  if (responseInit) {
    if (responseInit.status &lt; 200 || responseInit.status &gt; 599) throw new RangeError('Status code ' + responseInit.status + ' not
 in range');
    var statusText = responseInit.statusText || HTTP.STATUS_CODES[responseInit.status] || 'Unknown';
    if (!/^[^\n\r]+$/.test(statusText)) throw new TypeError('Status text ' + responseInit.statusText + ' not valid format');

    this._url = URL.format(responseInit.url || '');
    this.type = 'default';
    this.status = responseInit.status;
    this.statusText = statusText;
    this.headers = new Headers(responseInit.headers);
  } else {
    this.type = 'error';
    this.status = 0;
    this.statusText = '';
    this.headers = new Headers();
  }
  if (this._contentType &amp;&amp; !this.headers.has('Content-Type')) this.headers.set('Content-Type', this._contentType);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      var pathname = _URL$parse2.pathname;

      if (protocol === 'file:') {

// If the request is for a file:// descriptor, just open directly from the
// file system rather than getting node's http (which handles file://
// poorly) involved.
if (request.method !== 'GET') return new Fetch.<span class="apidocCodeKeywordSpan">Response</span>('', { url
: url, status: 405 });

var filename = Path.normalize(decodeURI(pathname));
var exists = File.existsSync(filename);
if (exists) {
  var stream = File.createReadStream(filename);
  return new Fetch.Response(stream, { url: url, status: 200 });
} else return new Fetch.Response('', { url: url, status: 404 });
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.zombie._debug" id="apidoc.element.zombie._debug">
        function <span class="apidocSignatureSpan">zombie.</span>_debug
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function debug() {
  // disabled?
  if (!debug.enabled) return;

  var self = debug;

  // set `diff` timestamp
  var curr = +new Date();
  var ms = curr - (prevTime || curr);
  self.diff = ms;
  self.prev = prevTime;
  self.curr = curr;
  prevTime = curr;

  // turn the `arguments` into a proper Array
  var args = new Array(arguments.length);
  for (var i = 0; i &lt; args.length; i++) {
    args[i] = arguments[i];
  }

  args[0] = exports.coerce(args[0]);

  if ('string' !== typeof args[0]) {
    // anything else let's inspect with %O
    args.unshift('%O');
  }

  // apply any `formatters` transformations
  var index = 0;
  args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match, format) {
    // if we encounter an escaped % then don't increase the array index
    if (match === '%%') return match;
    index++;
    var formatter = exports.formatters[format];
    if ('function' === typeof formatter) {
      var val = args[index];
      match = formatter.call(self, val);

      // now we need to remove `args[index]` since it's inlined in the `format`
      args.splice(index, 1);
      index--;
    }
    return match;
  });

  // apply env-specific formatting (colors, etc.)
  exports.formatArgs.call(self, args);

  var logFn = debug.log || exports.log || console.log.bind(console);
  logFn.apply(self, args);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
this._debug = Browser._debug;

// Message written to window.console.  Level is log, info, error, etc.
//
// All output goes to stdout, except when browser.silent = true and output
// only shown when debugging (DEBUG=zombie).
this.on('console', function (level, message) {
  if (_this.silent) _this.<span class="apidocCodeKeywordSpan">_debug</span>('&gt;&gt; ' + message);else console.log
(message);
}).on('log', function () {
  // Message written to browser.log.
  _this._debug(format.apply(undefined, arguments));
});

// Logging resources
this.on('request', function (request) {
...</pre></li>
    </ul>






















</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
</body></html>